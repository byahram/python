-- 트랜잭션
-- 트랜잭션은 더 이상 분할할 수 없는 최소 수행 단위를 뜻함
-- 하나의 작업 또는 밀접하게 연관된 작업을 수행하기 위해 한 개 이상의 데이터 조작 명령어(DML)로 이루어짐
-- 즉, 어떤 기능 한 가지를 수행하는 'SQL문 덩어리' 라고도 볼 수 있음

-- 트랜잭션을 제어하기 위해서 사용하는 명령어를 TCL(Transaction Control Language)라고 함

-- 트랜잭션은 데이터베이스 계정을 통해 접속하는 동시에 시작되고
-- 여러 SQL문을 실행하고 트랜잭션을 제어하는 명령어를 실행할 때 기존 트랜잭션이 종료
-- 그리고 그 후에 새로운 트랜잭션이 다시 시작

-- 하나의 트랜잭션에 묶여 있는 데이터 조작어의 수행 상태는
-- 모든 명령어가 정상적으로 수행 완료된 상태 또는
-- 모든 명령어가 수행되지 않아 취소된 상태
-- 두 가지 상태로만 존재함

-- 트랜잭션 명령어는 데이터 조작 상태를 이 두 가지 중 하나로 유도하는 명령어
-- 즉, 데이터 조작을 데이터베이스에 영구적으로 반영하거나 작업 전체를 취소

-- TCL을 연습할 mem_tcl 테이블 만들기
create table mem_tcl as select mem_id, mem_name, mem_number from member;

select * from mem_tcl;

-- mem_tcl 테이블에 데이터를 입력, 수정, 삭제
insert into mem_tcl values ('ASP', '에스파', 4);

update mem_tcl set mem_number = 5 where mem_name = '에스파';

delete from mem_tcl where mem_name = '에이핑크';

-- ROLLBACK 으로 명령어 실행 취소
-- ROLLBACK : 현재 트랜잭션에 포함된 데이터 조작 관련 명령어의 수행을 모두 취소
rollback;

-- 위에서 실행한 세 개의 데이터 조작어는 하나의 트랜잭션에 속해있음
-- 이 모든 작업을 취소하고 싶다면 ROLLBACK을 사용

select * from mem_tcl;

-- mem_tcl 테이블에 데이터를 입력, 수정, 삭제
insert into mem_tcl values ('IVE', '아이브', 6);

update mem_tcl set mem_id = 'PINK' where mem_id = 'APN';

delete from mem_tcl where mem_id = 'BLK';

-- COMMIT 으로 명령어 반영
commit;

-- commit 명령어는 지금까지 트랜잭션에서 데이터 조작 관련 명령어를 통해 변경된 데이터를
-- 모두 데이터베이스에 영구적으로 반영

-- commit을 사용한 후로는 rollback으로도 되돌릴 수 없음

-- 실무에서도 commit을 잘못 실행해서 문제가 되는 경우가 많음
-- 트랜잭션 작업이 정상적으로 수행되었다고 확신할 때 사용해야함


-- 세션
-- 데이터베이스에서 세션은 데이터베이스 접속부터 여러 가지 데이터베이스 작업을 수행한 후 접속을 종료하기까지
-- 전체 기간을 의미

-- 그러므로 세션이 여러 개라는 말은 현재 데이터베이스에 접속하여 사용 중인 연결이 여러 개 있다는 뜻

-- 세션 내부에는 하나 이상의 트랜잭션이 존재
-- 세션은 트랜잭션보다 큰 개념임

-- 데이터베이스는 여러 곳에서 동시에 접근하여 데이터를 관리, 사용하는 것이 목적이기 때문에
-- 보통 수많은 세션이 동시에 연결되어 있음

-- 이 때 어떤 특정 세션에서 테이블의 데이터를 변경 중일 때 그 외 다른 세션에서는 데이터의 변경이 확정되기 전까지는
-- 현재 진행중인 변경과 무관한 본래의 데이터를 보여주는 특성을 읽기 일관성 이라고 함

select * from mem_tcl;

-- dbeaver에서 데이터 삭제 후 다시 조회
delete from mem_tcl where mem_id = 'IVE';

-- DBEAVER 에서는 아이브가 삭제된 상태로 조회되고
-- CMD에서는 아이브가 삭제되기 전 상태로 출력됨

-- DBEAVER에서 실행한 DELETE문의 실행 결과가 아직 데이터베이스에 반영되지 않았기 때문(COMMIT되지 않음)
-- 어떤 데이터 조작이 포함된 트랜잭션이 완료 되기 전까지는 데이터를 직접 조작하는 세션 외의 다른 세션에서는
-- 데이터 조작 전의 상태가 일관적으로 조회, 출력, 검색되는 특성이 읽기 일관성(read consistency)

commit;

-- commit을 실행한 후에는 DELETE문의 수행 결과가 데이터베이스에 완전히 반영되어서
-- 다른 세션에서도 아이브가 삭제된 상태로 조회됨

-- 하나의 데이터베이스에는 수많은 세션이 연결되고 각 세션에서는 데이터 조작 명령어가 포함된 여러 트랜잭션이
-- 끊임없이 시작되고 종료되면서 실시간으로 작업이 수행됨

-- 데이터를 직접 변경중인 해당 세션을 제외한 모든 세션은 다른 세션의 데이터 변경과 상관없이 이미 확정된 데이터만
-- 검색됨으로써 읽기 일관성을 보장


-- LOCK
-- 특정 세션에서 조작 중인 데이터는 트랜잭션이 완료되기 전까지 다른 세션에서 조작할 수 없는 상태가 됨
-- 이렇게 데이터를 잠그는 것을 LOCK 이라고함
-- 다시 말하면 조작중인 데이터를 다른 세션에서 조작할 수 없도록 접근을 보류시키는 것

select * from mem_tcl;

-- 데이터 수정
update mem_tcl set mem_id = 'GIRL' where mem_name = '소녀시대';

-- dbeaver에서는 소녀시대의 mem_id 가 'GIRL' 로 변경되었지만 commit 이 되기 전이기 때문에
-- cmd에서는 소녀시대의 mem_id에 변화가 없음

-- dbeaver에서 mem_tcl 테이블의 소녀시대 데이터를 먼저 조작하고 있기 때문에 cmd 에서는 아무런 동작이
-- 일어나지 않음
-- dbeaver에서 commit 또는 rollback을 수행하기 전까지 소녀시대 행 데이터를 조작하려는 다른 세션은
-- 작업을 대기

-- 이렇게 데이터 조작이 완료될 때까지 다른 세션에서 해당 데이터 조작을 기다리는 현상을 HANG(행) 이라고 함

commit;

select * from mem_tcl;

-- LOCK은 하나의 데이터를 여러 곳에서 동시에 조작하려고 할 때 발생할 수 있는 혼란을 최소화하기 위한 요소
-- 위의 예제와 같이 SQL문으로 조작하는 대상 데이터가 테이블의 특정 행 데이터일 경우에는
-- 해당 행 만 LOCK이 발생한다는 의미로 행 레벨 록(ROW LEVEL LOCK) 이라고 정의

-- 만약에 where 절을 지정하지 않은 update나 delete 문일 경우에는 테이블의 모든 행 데이터에
-- 영향을 주는 명령어이기 때문에
-- 이 경우는 테이블에 저장되어 있는 전체 행이 LOCK 상태가 됨

-- 하지만 테이블 전체 행이 LOCK 상태여도 INSERT 문의 수행은 가능

-- 테이블에 변경되는 행의 수와는 관계없이 데이터 조작 명령어를 사용해서 데이터가 변경 중인 테이블은
-- 테이블 단위 잠금이라는 의미로 테이블 레벨 록(TABLE LEVEL LOCK)이 걸림
-- 즉, 데이터를 변경 중인 세션 외 다른 세션에서 테이블 구조를 변경할 수 없음